From 6bdfb51b468959c6c40a1d00c1234dd30a6b134e Mon Sep 17 00:00:00 2001
From: vincent <vbusoenseirb@gmail.com>
Date: Wed, 4 Dec 2019 23:24:31 +0100
Subject: [PATCH] fbtft changes: text overlay, soft rotation

---
 arch/arm/boot/dts/sun8i-v3s-funkey.dts |   3 +-
 drivers/staging/fbtft/Makefile         |   2 +-
 drivers/staging/fbtft/fb_st7789v.c     |  11 +-
 drivers/staging/fbtft/fbtft-bus.c      |   3 +-
 drivers/staging/fbtft/fbtft-core.c     | 458 +++++++++++++++++++++++++++++++--
 drivers/staging/fbtft/fbtft-io.c       |   1 +
 drivers/staging/fbtft/fbtft-sysfs.c    | 247 ++++++++++++++++++
 drivers/staging/fbtft/fbtft.h          |  32 ++-
 8 files changed, 722 insertions(+), 35 deletions(-)

diff --git a/arch/arm/boot/dts/sun8i-v3s-funkey.dts b/arch/arm/boot/dts/sun8i-v3s-funkey.dts
index 19062fc..181029d 100644
--- a/arch/arm/boot/dts/sun8i-v3s-funkey.dts
+++ b/arch/arm/boot/dts/sun8i-v3s-funkey.dts
@@ -179,7 +179,8 @@
                txbuflen = <115202>;
 //               txbuflen = <0>;
                rotate = <0>;
-               fps = <50>;
+               rotate_soft = <270>;
+               fps = <100>;
                buswidth = <8>;
                reset-gpios = <&pio 4 1 GPIO_ACTIVE_LOW>;	//PE1
                dc-gpios = <&pio 2 0 GPIO_ACTIVE_LOW>;		//PC0 (MISO)
diff --git a/drivers/staging/fbtft/Makefile b/drivers/staging/fbtft/Makefile
index 6bc0331..c74518e 100644
--- a/drivers/staging/fbtft/Makefile
+++ b/drivers/staging/fbtft/Makefile
@@ -1,7 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 # Core module
 obj-$(CONFIG_FB_TFT)             += fbtft.o
-fbtft-y                          += fbtft-core.o fbtft-sysfs.o fbtft-bus.o fbtft-io.o
+fbtft-y                          += fbtft-core.o fbtft-sysfs.o fbtft-bus.o fbtft-io.o fb_text.o
 
 # drivers
 obj-$(CONFIG_FB_TFT_AGM1264K_FL) += fb_agm1264k-fl.o
diff --git a/drivers/staging/fbtft/fb_st7789v.c b/drivers/staging/fbtft/fb_st7789v.c
index 212836f..fbf9620 100755
--- a/drivers/staging/fbtft/fb_st7789v.c
+++ b/drivers/staging/fbtft/fb_st7789v.c
@@ -153,8 +153,15 @@ static int init_display(struct fbtft_par *par)
 	/* Display Inversion of colors */
 	write_reg(par, 0x21);
 
-	/* 39Hz refresh rate */
-	write_reg(par, 0xC6,0x1F);
+	/* refresh rate */
+	//write_reg(par, 0xC6,0x1F); //39Hz 
+	//write_reg(par, 0xC6,0x1A); //44Hz 
+	//write_reg(par, 0xC6,0x17); //48Hz 
+	//write_reg(par, 0xC6,0x15); //50Hz 
+	//write_reg(par, 0xC6,0x12); //55Hz 
+	write_reg(par, 0xC6,0x10); //58Hz 
+	//write_reg(par, 0xC6,0x0F); //60Hz
+	//write_reg(par, 0xC6,0x03); //99Hz
 
 	write_reg(par, MIPI_DCS_SET_DISPLAY_ON);
 
diff --git a/drivers/staging/fbtft/fbtft-bus.c b/drivers/staging/fbtft/fbtft-bus.c
index 2a8eef1..dbc24e3 100644
--- a/drivers/staging/fbtft/fbtft-bus.c
+++ b/drivers/staging/fbtft/fbtft-bus.c
@@ -127,7 +127,8 @@ int fbtft_write_vmem16_bus8(struct fbtft_par *par, size_t offset, size_t len)
 		__func__, offset, len);
 
 	remain = len / 2;
-	vmem16 = (u16 *)(par->info->screen_buffer + offset);
+	//vmem16 = (u16 *)(par->info->screen_buffer + offset);
+	vmem16 = (u16 *)(par->vmem_post_process + offset);
 
 	if (par->gpio.dc != -1)
 		gpio_set_value(par->gpio.dc, 1);
diff --git a/drivers/staging/fbtft/fbtft-core.c b/drivers/staging/fbtft/fbtft-core.c
index 7dce967..ab23fb4 100755
--- a/drivers/staging/fbtft/fbtft-core.c
+++ b/drivers/staging/fbtft/fbtft-core.c
@@ -35,14 +35,27 @@
 #include <linux/of.h>
 #include <linux/of_gpio.h>
 #include <video/mipi_display.h>
+#include <linux/hrtimer.h>
+#include <linux/list.h>
+
+/* to support deferred IO */
+#include <linux/rmap.h>
+#include <linux/pagemap.h>
 
 #include "fbtft.h"
+#include "fb_text.h"
 #include "internal.h"
 
 static unsigned long debug;
 module_param(debug, ulong, 0000);
 MODULE_PARM_DESC(debug, "override device debug level");
 
+/*
+unsigned long timer_interval_ns = 100e6; //16ms for approximately 60fps
+static struct hrtimer hr_timer;
+static struct fbtft_par *saved_fbtft_par = NULL;
+*/
+
 int fbtft_write_buf_dc(struct fbtft_par *par, void *buf, size_t len, int dc)
 {
 	int ret;
@@ -331,11 +344,27 @@ void fbtft_register_backlight(struct fbtft_par *par)
 static void fbtft_set_addr_win(struct fbtft_par *par, int xs, int ys, int xe,
 			       int ye)
 {
-	write_reg(par, MIPI_DCS_SET_COLUMN_ADDRESS,
-		  (xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);
-
-	write_reg(par, MIPI_DCS_SET_PAGE_ADDRESS,
-		  (ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);
+	static int prev_xs = -1;
+	static int prev_ys = -1;
+	static int prev_xe = -1;
+	static int prev_ye = -1;
+
+	// Check if values need to be sent
+	if(prev_xs!=xs || prev_ys!=ys || prev_xe!=xe || prev_ye!=ye){
+
+		// Save prev bounding box values
+		prev_xs = xs;
+		prev_ys = ys;
+		prev_xe = xe;
+		prev_ye = ye;
+
+		//Set new bounding Box
+		write_reg(par, MIPI_DCS_SET_COLUMN_ADDRESS,
+			  (xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);
+
+		write_reg(par, MIPI_DCS_SET_PAGE_ADDRESS,
+			  (ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);
+	}
 
 	write_reg(par, MIPI_DCS_WRITE_MEMORY_START);
 }
@@ -356,10 +385,12 @@ static void fbtft_update_display(struct fbtft_par *par, unsigned int start_line,
 {
 	size_t offset, len;
 	ktime_t ts_start, ts_end;
-	long fps, throughput;
+	long fps, throughput, write_time;
 	bool timeit = false;
 	int ret = 0;
 
+	//printk("fbtft_update_display\r\n");
+
 	if (unlikely(par->debug & (DEBUG_TIME_FIRST_UPDATE |
 			DEBUG_TIME_EACH_UPDATE))) {
 		if ((par->debug & DEBUG_TIME_EACH_UPDATE) ||
@@ -372,6 +403,12 @@ static void fbtft_update_display(struct fbtft_par *par, unsigned int start_line,
 
 	/* Sanity checks */
 	if (start_line > end_line) {
+
+		/* Special case: no update needed */
+		if(start_line == (par->info->var.yres - 1) || end_line == 0){
+			return;
+		}
+
 		dev_warn(par->info->device,
 			 "%s: start_line=%u is larger than end_line=%u. Shouldn't happen, will do full display update\n",
 			 __func__, start_line, end_line);
@@ -387,20 +424,21 @@ static void fbtft_update_display(struct fbtft_par *par, unsigned int start_line,
 		start_line = 0;
 		end_line = par->info->var.yres - 1;
 	}
+	
+	/* Reset write Window and init write cmd */
+	if (par->fbtftops.set_addr_win){
 
-	fbtft_par_dbg(DEBUG_UPDATE_DISPLAY, par, "%s(start_line=%u, end_line=%u)\n",
+		fbtft_par_dbg(DEBUG_UPDATE_DISPLAY, par, "%s(start_line=%u, end_line=%u)\n",
 		      __func__, start_line, end_line);
-
-	// Carefull removing this. this will work only if the full screen is updated all at once
-	if (par->fbtftops.set_addr_win){
 		par->fbtftops.set_addr_win(par, 0, start_line,
 				par->info->var.xres - 1, end_line);
+		/*if (par->fbtftops.set_addr_win){
+			par->fbtftops.set_addr_win(par, 80, start_line,
+					320 - 1, end_line);
+		}*/
 	}
-	/*if (par->fbtftops.set_addr_win){
-		par->fbtftops.set_addr_win(par, 80, start_line,
-				320 - 1, end_line);
-	}*/
-
+	
+	/* Send data over SPI */
 	offset = start_line * par->info->fix.line_length;
 	len = (end_line - start_line + 1) * par->info->fix.line_length;
 	ret = par->fbtftops.write_vmem(par, offset, len);
@@ -409,6 +447,7 @@ static void fbtft_update_display(struct fbtft_par *par, unsigned int start_line,
 			"%s: write_vmem failed to update display buffer\n",
 			__func__);
 
+	/* Debug */
 	if (unlikely(timeit)) {
 		ts_end = ktime_get();
 		if (!ktime_to_ns(par->update_time))
@@ -418,19 +457,74 @@ static void fbtft_update_display(struct fbtft_par *par, unsigned int start_line,
 		par->update_time = ts_start;
 		fps = fps ? 1000000 / fps : 0;
 
-		throughput = ktime_us_delta(ts_end, ts_start);
-		throughput = throughput ? (len * 1000) / throughput : 0;
+		write_time = ktime_us_delta(ts_end, ts_start);
+		throughput = write_time ? (len * 1000) / write_time : 0;
 		throughput = throughput * 1000 / 1024;
 
-		dev_info(par->info->device,
+		if(fps){
+			par->avg_fps += fps;
+			par->nb_fps_values++;
+
+			if(par->nb_fps_values == 120){
+				dev_info(par->info->device,
+					 "Display update: %ld kB/s, write_time: %ldus, fps=%ld\n",
+					 throughput, write_time, par->avg_fps/par->nb_fps_values);
+				par->avg_fps = 0;
+				par->nb_fps_values = 0;
+			}
+		}
+
+		/*dev_info(par->info->device,
 			 "Display update: %ld kB/s, fps=%ld\n",
-			 throughput, fps);
+			 throughput, fps);*/
 		par->first_update_done = true;
 	}
+
+	// Hack: Force schedule new entire display upgrade
+	//par->fbtftops.mkdirty(par->info, -1, 0);
+}
+
+/* Soft Matrix Rotation - Works only on square 2D matrices */
+static void fbtft_rotate_soft(u16 *mat, int size, int rotation){
+	int i, j;
+	u16 temp;
+	int N = size;
+
+	#define AT(i, j) 	(i)*N+(j)
+	
+	if(rotation == 90)
+	{
+	  	/* Rotate screen 90° Clockwise */
+	  	for (i = 0; i < N / 2; i++) { 
+	        for (j = i; j < N - i - 1; j++) { 
+	            temp = mat[AT(i, j)]; 
+	            mat[AT(i, j)] = mat[AT(N - 1 - j, i)]; 
+	            mat[AT(N - 1 - j, i)] = mat[AT(N - 1 - i, N - 1 - j)]; 
+	            mat[AT(N - 1 - i, N - 1 - j)] = mat[AT(j, N - 1 - i)]; 
+	            mat[AT(j, N - 1 - i)] = temp; 
+	        } 
+	    } 
+	}
+	else if(rotation == 270)
+	{
+	  	/* Rotate screen 270° Clockwise */
+	  	for (i = 0; i < N / 2; i++) { 
+	        for (j = i; j < N - i - 1; j++) { 
+	            temp = mat[AT(i, j)]; 
+	            mat[AT(i, j)] = mat[AT(j, N-1-i)]; 
+	            mat[AT(j, N-1-i)] = mat[AT(N - 1 - i, N - 1 - j)]; 
+	            mat[AT(N - 1 - i, N - 1 - j)] = mat[AT(N - 1 - j, i)]; 
+	            mat[AT(N - 1 - j, i)] = temp; 
+	        } 
+	    } 
+	}
 }
 
 static void fbtft_mkdirty(struct fb_info *info, int y, int height)
 {
+	// Hack for using hrtimers instead
+	//return;
+
 	struct fbtft_par *par = info->par;
 	struct fb_deferred_io *fbdefio = info->fbdefio;
 
@@ -454,12 +548,17 @@ static void fbtft_mkdirty(struct fb_info *info, int y, int height)
 
 static void fbtft_deferred_io(struct fb_info *info, struct list_head *pagelist)
 {
+	// Hack for using hrtimers instead
+	//return;
 	struct fbtft_par *par = info->par;
+#if 1
 	unsigned int dirty_lines_start, dirty_lines_end;
 	struct page *page;
 	unsigned long index;
 	unsigned int y_low = 0, y_high = 0;
 	int count = 0;
+	int x_notif, y_notif;
+	u16 *arr = (u16*)par->vmem_post_process;
 
 	spin_lock(&par->dirty_lock);
 	dirty_lines_start = par->dirty_lines_start;
@@ -469,6 +568,10 @@ static void fbtft_deferred_io(struct fb_info *info, struct list_head *pagelist)
 	par->dirty_lines_end = 0;
 	spin_unlock(&par->dirty_lock);
 
+	// Hack: Force schedule new display upgrade
+	//par->fbtftops.mkdirty(par->info, par->dirty_lines_start, par->dirty_lines_end);
+
+
 	/* Mark display lines as dirty */
 	list_for_each_entry(page, pagelist, lru) {
 		count++;
@@ -476,8 +579,8 @@ static void fbtft_deferred_io(struct fb_info *info, struct list_head *pagelist)
 		y_low = index / info->fix.line_length;
 		y_high = (index + PAGE_SIZE - 1) / info->fix.line_length;
 		dev_dbg(info->device,
-			"page->index=%lu y_low=%d y_high=%d\n",
-			page->index, y_low, y_high);
+			"count=%d, page->index=%lu y_low=%d y_high=%d\n",
+			count, page->index, y_low, y_high);
 		if (y_high > info->var.yres - 1)
 			y_high = info->var.yres - 1;
 		if (y_low < dirty_lines_start)
@@ -486,10 +589,97 @@ static void fbtft_deferred_io(struct fb_info *info, struct list_head *pagelist)
 			dirty_lines_end = y_high;
 	}
 
+	/* Copy buffer */
+	memcpy(par->vmem_post_process + dirty_lines_start * par->info->fix.line_length, 
+		par->info->screen_buffer + dirty_lines_start * par->info->fix.line_length, 
+		(dirty_lines_end-dirty_lines_start+1) * par->info->fix.line_length);
+
+	/* Notifications */
+	if(par->notification[0]){
+		x_notif = 1;
+		y_notif = 20;
+	  	DrawText((u16*)par->vmem_post_process, info->var.xres, info->var.xres*2, info->var.yres, 
+	  		par->notification, x_notif, y_notif, RGB565(255, 255, 255), 0);
+	  	if (y_notif < dirty_lines_start)
+			dirty_lines_start = y_notif;
+		if (y_notif + MONACO_HEIGHT > dirty_lines_end)
+			dirty_lines_end = y_notif + MONACO_HEIGHT;
+	}
+
+	/* Soft rotation */
+	if(par->pdata->rotate_soft)
+	{
+	  	/* Rotation  */
+	  	fbtft_rotate_soft(arr, info->var.yres, par->pdata->rotate_soft);
+
+	  	/* Mark whole screen to update (square matrix) */
+		dirty_lines_start = 0;
+		dirty_lines_end = info->var.yres-1;
+	}
+
+	/* Screen upgrade */
+	par->fbtftops.update_display(par, dirty_lines_start, dirty_lines_end);
+#endif
+
+#if 0
+	// Full display update
 	par->fbtftops.update_display(info->par,
-					dirty_lines_start, dirty_lines_end);
+					0, par->info->var.yres - 1);
+#endif
+}
+
+#if 0
+enum hrtimer_restart update_display_timer_callback( struct hrtimer *timer_for_restart )
+{
+  	ktime_t currtime , interval;
+  	currtime  = ktime_get();
+  	interval = ktime_set(0,timer_interval_ns); 
+  	//hrtimer_forward(timer_for_restart, currtime , interval);
+
+  	ktime_t now = hrtimer_cb_get_time(timer_for_restart);                               
+	u64 overrun = hrtimer_forward(timer_for_restart, now, interval);
+	
+  	// Update whole display
+  	struct fbtft_par *par = saved_fbtft_par;
+  	if(par){
+		//par->dirty_lines_start = 0;
+		//par->dirty_lines_end = par->info->var.yres - 1;
+		/*if(par->fbtftops.update_display){
+			// update the entire display 
+			par->fbtftops.update_display(par, 0, par->info->var.yres - 1);
+		}*/
+		//schedule_delayed_work(&par->info->deferred_work, 0);
+			
+		// update the entire display 
+		schedule_delayed_work(&saved_fbtft_par->info->deferred_work, 0);
+  	}
+
+  	//printk("update_display_timer_callback\n");
+
+	return HRTIMER_RESTART;
+}
+
+static int __init update_display_timer_init(void) {
+	ktime_t ktime = ktime_set( 0, timer_interval_ns );
+	printk(KERN_ERR "Timer being set up\n");
+	hrtimer_init( &hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	hr_timer.function = &update_display_timer_callback;
+ 	hrtimer_start( &hr_timer, ktime, HRTIMER_MODE_REL);
+	return 0;
+}
+
+static void __exit update_display_timer_exit(void) {
+	int ret;
+  	ret = hrtimer_cancel( &hr_timer );
+  	if (ret) printk("The timer was still in use...\n");
+  	printk("HR Timer module uninstalling\n");
+	
 }
 
+/*module_init(update_display_timer_init);
+module_exit(update_display_timer_exit);*/
+#endif
+
 static void fbtft_fb_fillrect(struct fb_info *info,
 			      const struct fb_fillrect *rect)
 {
@@ -545,6 +735,214 @@ static ssize_t fbtft_fb_write(struct fb_info *info, const char __user *buf,
 	return res;
 }
 
+static struct page *fb_deferred_io_page(struct fb_info *info, unsigned long offs)
+{
+	void *screen_base = (void __force *) info->screen_base;
+	struct page *page;
+
+	if (is_vmalloc_addr(screen_base + offs))
+		page = vmalloc_to_page(screen_base + offs);
+	else
+		page = pfn_to_page((info->fix.smem_start + offs) >> PAGE_SHIFT);
+
+	return page;
+}
+
+/* this is to find and return the vmalloc-ed fb pages */
+static int fb_deferred_io_fault(struct vm_fault *vmf)
+{
+	unsigned long offset;
+	struct page *page;
+	struct fb_info *info = vmf->vma->vm_private_data;
+
+	offset = vmf->pgoff << PAGE_SHIFT;
+	if (offset >= info->fix.smem_len)
+		return VM_FAULT_SIGBUS;
+
+	page = fb_deferred_io_page(info, offset);
+	if (!page)
+		return VM_FAULT_SIGBUS;
+
+	get_page(page);
+
+	if (vmf->vma->vm_file)
+		page->mapping = vmf->vma->vm_file->f_mapping;
+	else
+		printk(KERN_ERR "no mapping available\n");
+
+	BUG_ON(!page->mapping);
+	page->index = vmf->pgoff;
+
+	vmf->page = page;
+	return 0;
+}
+
+/* vm_ops->page_mkwrite handler */
+static int fb_deferred_io_mkwrite(struct vm_fault *vmf)
+{
+	struct page *page = vmf->page;
+	struct fb_info *info = vmf->vma->vm_private_data;
+	struct fb_deferred_io *fbdefio = info->fbdefio;
+	struct page *cur;
+
+	/* this is a callback we get when userspace first tries to
+	write to the page. we schedule a workqueue. that workqueue
+	will eventually mkclean the touched pages and execute the
+	deferred framebuffer IO. then if userspace touches a page
+	again, we repeat the same scheme */
+
+	file_update_time(vmf->vma->vm_file);
+
+	/* protect against the workqueue changing the page list */
+	mutex_lock(&fbdefio->lock);
+
+	/* first write in this cycle, notify the driver */
+	if (fbdefio->first_io && list_empty(&fbdefio->pagelist))
+		fbdefio->first_io(info);
+
+	/*
+	 * We want the page to remain locked from ->page_mkwrite until
+	 * the PTE is marked dirty to avoid page_mkclean() being called
+	 * before the PTE is updated, which would leave the page ignored
+	 * by defio.
+	 * Do this by locking the page here and informing the caller
+	 * about it with VM_FAULT_LOCKED.
+	 */
+	lock_page(page);
+
+#if 0
+	int add_page = 1;
+	unsigned int y_low = 0, y_high = 0;
+	unsigned int dirty_lines_start = info->var.yres - 1;
+	int dirty_lines_end = 0;
+	unsigned long index;
+	int count=0;
+
+	/* we loop through the pagelist before adding in order
+	to keep the pagelist sorted */
+	list_for_each_entry(cur, &fbdefio->pagelist, lru) {
+
+		/* this is to find the lower and higher y positions already dirtied */
+		count++;
+		index = cur->index << PAGE_SHIFT;
+		y_low = index / info->fix.line_length;
+		y_high = (index + PAGE_SIZE - 1) / info->fix.line_length;
+		if (y_low < dirty_lines_start)
+			dirty_lines_start = y_low;
+		if (y_high > dirty_lines_end)
+			dirty_lines_end = y_high;
+
+		/* this check is to catch the case where a new
+		process could start writing to the same page
+		through a new pte. this new access can cause the
+		mkwrite even when the original ps's pte is marked
+		writable */
+		if (unlikely(cur == page))
+			add_page = 0;
+		/*else if (cur->index > page->index)
+			break;*/
+	}
+
+	if(add_page){
+		list_add_tail(&page->lru, &cur->lru);
+
+		/* let's not forget the boundaries of our current page */
+		count++;
+		index = page->index << PAGE_SHIFT;
+		y_low = index / info->fix.line_length;
+		y_high = (index + PAGE_SIZE - 1) / info->fix.line_length;
+		if (y_low < dirty_lines_start)
+			dirty_lines_start = y_low;
+		if (y_high > dirty_lines_end)
+			dirty_lines_end = y_high;
+	}
+
+	mutex_unlock(&fbdefio->lock);
+
+	//printk("count=%d, dirty_lines_start=%d, dirty_lines_end=%d\n", count, dirty_lines_start, dirty_lines_end);
+
+	/* If whole screen was written, update now */
+	if(dirty_lines_start == 0 && dirty_lines_end >= info->var.yres - 1){
+		schedule_delayed_work(&info->deferred_work, 0);
+	}
+	/*else{
+		schedule_delayed_work(&info->deferred_work, fbdefio->delay);
+	}*/
+#endif
+
+#if 0
+	list_add_tail(&page->lru, &cur->lru);
+	mutex_unlock(&fbdefio->lock);
+	schedule_delayed_work(&info->deferred_work, 0);
+#endif
+
+#if 0
+	/* we loop through the pagelist before adding in order
+	to keep the pagelist sorted */
+	list_for_each_entry(cur, &fbdefio->pagelist, lru) {
+		/* this check is to catch the case where a new
+		process could start writing to the same page
+		through a new pte. this new access can cause the
+		mkwrite even when the original ps's pte is marked
+		writable */
+		if (unlikely(cur == page))
+			goto page_already_added;
+		else if (cur->index > page->index)
+			break;
+	}
+
+	list_add_tail(&page->lru, &cur->lru);
+
+page_already_added:
+	mutex_unlock(&fbdefio->lock);
+
+	/* come back after delay to process the deferred IO */
+	schedule_delayed_work(&info->deferred_work, fbdefio->delay);
+#endif
+
+#if 1
+	/* we loop through the pagelist before adding in order
+	to keep the pagelist sorted */
+	list_for_each_entry(cur, &fbdefio->pagelist, lru) {
+		/* this check is to catch the case where a new
+		process could start writing to the same page
+		through a new pte. this new access can cause the
+		mkwrite even when the original ps's pte is marked
+		writable */
+		if (unlikely(cur == page))
+			goto page_already_added;
+		else if (cur->index > page->index)
+			break;
+	}
+
+	list_add_tail(&page->lru, &cur->lru);
+
+page_already_added:
+	mutex_unlock(&fbdefio->lock);
+
+	/* Update by timers */
+	schedule_delayed_work(&info->deferred_work, fbdefio->delay);
+#endif
+
+
+	return VM_FAULT_LOCKED;
+}
+
+static const struct vm_operations_struct fb_deferred_io_vm_ops = {
+	.fault		= fb_deferred_io_fault,
+	.page_mkwrite	= fb_deferred_io_mkwrite,
+};
+
+static int fbtft_fb_deferred_io_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	vma->vm_ops = &fb_deferred_io_vm_ops;
+	vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
+	if (!(info->flags & FBINFO_VIRTFB))
+		vma->vm_flags |= VM_IO;
+	vma->vm_private_data = info;
+	return 0;
+}
+
 /* from pxafb.c */
 static unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)
 {
@@ -671,6 +1069,7 @@ struct fb_info *fbtft_framebuffer_alloc(struct fbtft_display *display,
 	struct fb_ops *fbops = NULL;
 	struct fb_deferred_io *fbdefio = NULL;
 	u8 *vmem = NULL;
+	u8 *vmem_post_process = NULL;
 	void *txbuf = NULL;
 	void *buf = NULL;
 	unsigned int width;
@@ -743,6 +1142,10 @@ struct fb_info *fbtft_framebuffer_alloc(struct fbtft_display *display,
 	if (!vmem)
 		goto alloc_fail;
 
+	vmem_post_process = kzalloc(vmem_size, GFP_DMA | GFP_KERNEL);
+	if (!vmem_post_process)
+		goto alloc_fail;
+
 	fbops = devm_kzalloc(dev, sizeof(struct fb_ops), GFP_KERNEL);
 	if (!fbops)
 		goto alloc_fail;
@@ -786,6 +1189,9 @@ struct fb_info *fbtft_framebuffer_alloc(struct fbtft_display *display,
 	fbdefio->deferred_io =     fbtft_deferred_io;
 	fb_deferred_io_init(info);
 
+	// Surcharge 
+	info->fbops->fb_mmap = fbtft_fb_deferred_io_mmap;
+
 	strncpy(info->fix.id, dev->driver->name, 16);
 	info->fix.type =           FB_TYPE_PACKED_PIXELS;
 	info->fix.visual =         FB_VISUAL_TRUECOLOR;
@@ -818,6 +1224,7 @@ struct fb_info *fbtft_framebuffer_alloc(struct fbtft_display *display,
 
 	par = info->par;
 	par->info = info;
+	par->vmem_post_process = vmem_post_process;
 	par->pdata = pdata;
 	par->debug = display->debug;
 	par->buf = buf;
@@ -1225,6 +1632,7 @@ int fbtft_init_display(struct fbtft_par *par)
 }
 EXPORT_SYMBOL(fbtft_init_display);
 
+
 /**
  * fbtft_verify_gpios() - Generic verify_gpios() function
  * @par: Driver data
@@ -1301,6 +1709,7 @@ static struct fbtft_platform_data *fbtft_probe_dt(struct device *dev)
 	pdata->display.bpp = fbtft_of_value(node, "bpp");
 	pdata->display.debug = fbtft_of_value(node, "debug");
 	pdata->rotate = fbtft_of_value(node, "rotate");
+	pdata->rotate_soft = fbtft_of_value(node, "rotate_soft");
 	pdata->bgr = of_property_read_bool(node, "bgr");
 	pdata->fps = fbtft_of_value(node, "fps");
 	pdata->txbuflen = fbtft_of_value(node, "txbuflen");
@@ -1436,10 +1845,15 @@ int fbtft_probe_common(struct fbtft_display *display,
 	/* use platform_data provided functions above all */
 	fbtft_merge_fbtftops(&par->fbtftops, &pdata->display.fbtftops);
 
+
 	ret = fbtft_register_framebuffer(info);
 	if (ret < 0)
 		goto out_release;
 
+	/* Save fbtft_par */
+	//saved_fbtft_par = par;
+  	//printk("saved_fbtft_par=0x%08X\n", saved_fbtft_par);
+
 	return 0;
 
 out_release:
diff --git a/drivers/staging/fbtft/fbtft-io.c b/drivers/staging/fbtft/fbtft-io.c
index f4a5919..b77dab5 100644
--- a/drivers/staging/fbtft/fbtft-io.c
+++ b/drivers/staging/fbtft/fbtft-io.c
@@ -25,6 +25,7 @@ int fbtft_write_spi(struct fbtft_par *par, void *buf, size_t len)
 	spi_message_init(&m);
 	spi_message_add_tail(&t, &m);
 	return spi_sync(par->spi, &m);
+	//return spi_async(par->spi, &m);
 }
 EXPORT_SYMBOL(fbtft_write_spi);
 
diff --git a/drivers/staging/fbtft/fbtft-sysfs.c b/drivers/staging/fbtft/fbtft-sysfs.c
index 7120966..a006c30 100644
--- a/drivers/staging/fbtft/fbtft-sysfs.c
+++ b/drivers/staging/fbtft/fbtft-sysfs.c
@@ -145,6 +145,244 @@ static ssize_t show_gamma_curve(struct device *device,
 	__ATTR(gamma, 0660, show_gamma_curve, store_gamma_curve),
 };
 
+int fbtft_overlay_parse_str(struct fbtft_par *par, u32 *values,
+			  const char *str, int size)
+{
+	char *str_p, *cur_line = NULL;
+	char *tmp;
+	unsigned long val = 0;
+	int ret = 0;
+	int line_counter, value_counter;
+
+	fbtft_par_dbg(DEBUG_SYSFS, par, "%s() str=%s\n", __func__, str);
+
+	if (!str || !values)
+		return -EINVAL;
+
+	fbtft_par_dbg(DEBUG_SYSFS, par, "%s\n", str);
+
+	tmp = kmemdup(str, size + 1, GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+
+	/* replace optional separators */
+	str_p = tmp;
+	while (*str_p) {
+		if (*str_p == ',')
+			*str_p = ' ';
+		str_p++;
+	}
+
+	str_p = strim(tmp);
+
+	line_counter = 0;
+	while (str_p) {
+		if (line_counter >= 1) {
+			dev_err(par->info->device, "Overlay: Too many lines\n");
+			ret = -EINVAL;
+			goto out;
+		}
+		cur_line = strsep(&str_p, "\n");
+		value_counter = 0;
+		while (cur_line) {
+			if (value_counter == FBTFT_OVERLAY_NB_VALUES) {
+				dev_err(par->info->device,
+					"Overlay: Too many values\n");
+				ret = -EINVAL;
+				goto out;
+			}
+			ret = get_next_ulong(&cur_line, &val, " ", 10);
+			if (ret)
+				goto out;
+
+			// Check width
+			if(value_counter == 2 && val > par->info->var.xres-1){
+				dev_err(par->info->device, "Overlay: width (%lu) > display width (%d)\n", 
+					val, par->info->var.xres);
+				ret = -EINVAL;
+				goto out;
+			}
+
+			// Check height
+			if(value_counter == 3 && val > par->info->var.yres-1){
+				dev_err(par->info->device, "Overlay: height (%lu) > display height (%d)\n", 
+					val, par->info->var.yres);
+				ret = -EINVAL;
+				goto out;
+			}
+
+			values[value_counter] = val;
+			value_counter++;
+		}
+		if (value_counter != FBTFT_OVERLAY_NB_VALUES) {
+			dev_err(par->info->device, "Overlay: Too few values\n");
+			ret = -EINVAL;
+			goto out;
+		}
+
+		// Check x
+		if(values[0] > values[2]){
+			dev_err(par->info->device, "Overlay: x (%u) > width (%u)\n", 
+				values[0], values[2]);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		// Check y
+		if(values[1] > values[3]){
+			dev_err(par->info->device, "Overlay: y (%u) > height (%u)\n", 
+				values[1], values[3]);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		line_counter++;
+	}
+
+out:
+	kfree(tmp);
+	return ret;
+}
+
+static ssize_t store_overlay(struct device *device,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct fb_info *fb_info = dev_get_drvdata(device);
+	struct fbtft_par *par = fb_info->par;
+	u32 tmp_overlay[FBTFT_OVERLAY_NB_VALUES];
+	int ret;
+
+	ret = fbtft_overlay_parse_str(par, tmp_overlay, buf, count);
+	if (ret)
+		return ret;
+
+	mutex_lock(&par->overlay.lock);
+	par->overlay.x = tmp_overlay[0];
+	par->overlay.y = tmp_overlay[1];
+	par->overlay.w = tmp_overlay[2];
+	par->overlay.h = tmp_overlay[3];
+	mutex_unlock(&par->overlay.lock);
+
+	return count;
+}
+
+static ssize_t show_overlay(struct device *device,
+				struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fb_info = dev_get_drvdata(device);
+	struct fbtft_par *par = fb_info->par;
+
+	ssize_t len = sprintf(buf, "%u,%u,%u,%u\n", par->overlay.x, par->overlay.y,
+		par->overlay.w, par->overlay.h);
+
+	return len;
+}
+
+static struct device_attribute overlay_device_attrs[] = {
+	__ATTR(overlay, 0660, show_overlay, store_overlay),
+};
+
+void fbtft_expand_rotate_soft_value(unsigned long *rotate_soft)
+{
+	switch (*rotate_soft) {
+	case 0:
+	case 90:
+	case 180:
+	case 270:
+		break;
+	case 1:
+		*rotate_soft = 90;
+		break;
+	case 2:
+		*rotate_soft = 180;
+		break;
+	case 3:
+		*rotate_soft = 270;
+	default:
+		printk("Wrong Rotate soft value: %lu\n", *rotate_soft);
+		 *rotate_soft = 0;
+		break;
+	}
+}
+
+static ssize_t store_rotate_soft(struct device *device,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct fb_info *fb_info = dev_get_drvdata(device);
+	struct fbtft_par *par = fb_info->par;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &par->pdata->rotate_soft);
+	if (ret)
+		return ret;
+	fbtft_expand_rotate_soft_value(&par->pdata->rotate_soft);
+
+	/* Schedule deferred_io to update display (no-op if already on queue)*/
+	par->dirty_lines_start = 0;
+	par->dirty_lines_end = par->info->var.yres - 1;
+	schedule_delayed_work(&par->info->deferred_work, par->info->fbdefio->delay);
+
+	return count;
+}
+
+static ssize_t show_rotate_soft(struct device *device,
+			  struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fb_info = dev_get_drvdata(device);
+	struct fbtft_par *par = fb_info->par;
+
+	return snprintf(buf, PAGE_SIZE, "%lu\n", par->pdata->rotate_soft);
+}
+
+static struct device_attribute rotate_soft_device_attr =
+	__ATTR(rotate_soft, 0660, show_rotate_soft, store_rotate_soft);
+
+static ssize_t store_notification(struct device *device,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct fb_info *fb_info = dev_get_drvdata(device);
+	struct fbtft_par *par = fb_info->par;
+	char *tmp;
+
+	fbtft_par_dbg(DEBUG_SYSFS, par, "%s(), count=%d, str=%s\n", __func__, count, buf);
+	//printk("%s(), count=%d, str=%s\n", __func__, count, buf);
+
+	tmp = kmemdup(buf, count + 1, GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+
+	/* Clear notif buffer if empty string */
+	if (!strcmp(buf, "clear")){
+		fbtft_par_dbg(DEBUG_SYSFS, par, "Clearing notif buffer\n");
+		par->notification[0] = 0;
+	}
+	else{
+		strncpy(par->notification, tmp, FBTFT_NOTIF_MAX_SIZE);
+	}
+
+	/* Schedule deferred_io to update display (no-op if already on queue)*/
+	par->dirty_lines_start = 0;
+	par->dirty_lines_end = par->info->var.yres - 1;
+	schedule_delayed_work(&par->info->deferred_work, par->info->fbdefio->delay);
+
+	return count;
+}
+
+static ssize_t show_notification(struct device *device,
+			  struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fb_info = dev_get_drvdata(device);
+	struct fbtft_par *par = fb_info->par;
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", par->notification);
+}
+
+static struct device_attribute notification_device_attr =
+	__ATTR(notification, 0660, show_notification, store_notification);
+
 void fbtft_expand_debug_value(unsigned long *debug)
 {
 	switch (*debug & 0x7) {
@@ -167,6 +405,9 @@ void fbtft_expand_debug_value(unsigned long *debug)
 		*debug |= DEBUG_LEVEL_6;
 		break;
 	case 7:
+		*debug = DEBUG_LEVEL_7; // FPS
+		break;
+	case 8:
 		*debug = 0xFFFFFFFF;
 		break;
 	}
@@ -203,6 +444,9 @@ static ssize_t show_debug(struct device *device,
 void fbtft_sysfs_init(struct fbtft_par *par)
 {
 	device_create_file(par->info->dev, &debug_device_attr);
+	device_create_file(par->info->dev, &rotate_soft_device_attr);
+	device_create_file(par->info->dev, &notification_device_attr);
+	device_create_file(par->info->dev, &overlay_device_attrs[0]);
 	if (par->gamma.curves && par->fbtftops.set_gamma)
 		device_create_file(par->info->dev, &gamma_device_attrs[0]);
 }
@@ -210,6 +454,9 @@ void fbtft_sysfs_init(struct fbtft_par *par)
 void fbtft_sysfs_exit(struct fbtft_par *par)
 {
 	device_remove_file(par->info->dev, &debug_device_attr);
+	device_remove_file(par->info->dev, &rotate_soft_device_attr);
+	device_remove_file(par->info->dev, &notification_device_attr);
+	device_remove_file(par->info->dev, &overlay_device_attrs[0]);
 	if (par->gamma.curves && par->fbtftops.set_gamma)
 		device_remove_file(par->info->dev, &gamma_device_attrs[0]);
 }
diff --git a/drivers/staging/fbtft/fbtft.h b/drivers/staging/fbtft/fbtft.h
index 488ab78..0caf1bb 100644
--- a/drivers/staging/fbtft/fbtft.h
+++ b/drivers/staging/fbtft/fbtft.h
@@ -20,15 +20,18 @@
 #include <linux/spi/spi.h>
 #include <linux/platform_device.h>
 
-#define FBTFT_ONBOARD_BACKLIGHT 2
+#define FBTFT_ONBOARD_BACKLIGHT 		2
 
-#define FBTFT_GPIO_NO_MATCH		0xFFFF
-#define FBTFT_GPIO_NAME_SIZE	32
-#define FBTFT_MAX_INIT_SEQUENCE      512
-#define FBTFT_GAMMA_MAX_VALUES_TOTAL 128
+#define FBTFT_GPIO_NO_MATCH				0xFFFF
+#define FBTFT_GPIO_NAME_SIZE			32
+#define FBTFT_MAX_INIT_SEQUENCE      	512
+#define FBTFT_GAMMA_MAX_VALUES_TOTAL 	128
+#define FBTFT_OVERLAY_NB_VALUES			4
 
-#define FBTFT_OF_INIT_CMD	BIT(24)
-#define FBTFT_OF_INIT_DELAY	BIT(25)
+#define FBTFT_NOTIF_MAX_SIZE			256
+
+#define FBTFT_OF_INIT_CMD				BIT(24)
+#define FBTFT_OF_INIT_DELAY				BIT(25)
 
 /**
  * struct fbtft_gpio - Structure that holds one pinname to gpio mapping
@@ -147,6 +150,7 @@ struct fbtft_platform_data {
 	struct fbtft_display display;
 	const struct fbtft_gpio *gpios;
 	unsigned int rotate;
+	unsigned long rotate_soft;
 	bool bgr;
 	unsigned int fps;
 	int txbuflen;
@@ -212,6 +216,7 @@ struct fbtft_par {
 		size_t len;
 	} txbuf;
 	u8 *buf;
+	u8 *vmem_post_process;
 	u8 startbyte;
 	struct fbtft_ops fbtftops;
 	spinlock_t dirty_lock;
@@ -235,9 +240,19 @@ struct fbtft_par {
 		int num_values;
 		int num_curves;
 	} gamma;
+	struct {
+		struct mutex lock;
+		u32 x;
+		u32 y;
+		u32 w;
+		u32 h;
+	} overlay;
+	char notification[FBTFT_NOTIF_MAX_SIZE+1];
 	unsigned long debug;
 	bool first_update_done;
 	ktime_t update_time;
+	long avg_fps;
+	int nb_fps_values;
 	bool bgr;
 	void *extra;
 };
@@ -363,7 +378,8 @@ static void __exit fbtft_driver_module_exit(void)                          \
 #define DEBUG_LEVEL_4	(DEBUG_LEVEL_2 | DEBUG_FB_READ | DEBUG_FB_WRITE | DEBUG_FB_FILLRECT | DEBUG_FB_COPYAREA | DEBUG_FB_IMAGEBLIT | DEBUG_FB_BLANK)
 #define DEBUG_LEVEL_5	(DEBUG_LEVEL_3 | DEBUG_UPDATE_DISPLAY)
 #define DEBUG_LEVEL_6	(DEBUG_LEVEL_4 | DEBUG_LEVEL_5)
-#define DEBUG_LEVEL_7	0xFFFFFFFF
+#define DEBUG_LEVEL_7	DEBUG_TIME_EACH_UPDATE
+#define DEBUG_LEVEL_8	0xFFFFFFFF
 
 #define DEBUG_DRIVER_INIT_FUNCTIONS (1<<3)
 #define DEBUG_TIME_FIRST_UPDATE     (1<<4)
-- 
1.9.1

